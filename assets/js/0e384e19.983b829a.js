"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[9671],{7876:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>s,default:()=>u,frontMatter:()=>r,metadata:()=>o,toc:()=>l});var i=n(5893),a=n(1151);const r={sidebar_position:1},s="Introduction",o={id:"intro",title:"Introduction",description:"Mutative - A JavaScript library for efficient immutable updates, 2-6x faster than naive handcrafted reducer, and more than 10x faster than Immer.",source:"@site/docs/intro.md",sourceDirName:".",slug:"/intro",permalink:"/docs/intro",draft:!1,unlisted:!1,editUrl:"https://github.com/unadlib/mutative/tree/main/website/docs/intro.md",tags:[],version:"current",lastUpdatedBy:"unadlib",lastUpdatedAt:1702112129,formattedLastUpdatedAt:"Dec 9, 2023",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",next:{title:"Getting Started",permalink:"/docs/category/getting-started"}},d={},l=[{value:"What is Mutative?",id:"what-is-mutative",level:2},{value:"Motivation",id:"motivation",level:2},{value:"Features and Benefits",id:"features-and-benefits",level:2},{value:"Credits",id:"credits",level:2}];function c(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Mutative"})," - A JavaScript library for efficient immutable updates, 2-6x faster than naive handcrafted reducer, and more than 10x faster than Immer."]}),"\n",(0,i.jsx)(t.h2,{id:"what-is-mutative",children:"What is Mutative?"}),"\n",(0,i.jsx)(t.p,{children:"Mutative can help simplify the updating of immutable data structures, such as those used in React and Redux. It allows you to write code in a mutable way for the draft object, and ultimately it produces a new immutable data structure (the next state), avoiding unnecessary accidental mutations or complex deep updates with spread operations."}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Syntax conciseness"}),": Mutative makes code more concise and intuitive by providing a draft object that can be directly modified. Traditional reducers require manual handling of object and array immutability, which often involves complex spread and copying operations."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Performance"}),": Mutative provides higher performance than manually written reducers, especially when processing large data structures."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Error reduction"}),": Writing immutable updates by hand is usually difficult, prone to errors, and cumbersome. It is easy to make the mistake of directly modifying the state, rather than returning the next state. Mutative avoids this type of problem through its design, as all modifications occur on the draft object, and finally a new immutable data is produced."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"For example, assume there is a state object that includes a list. We aim to mark the last item in the list as completed and then add a new item:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",children:"const state = {\n  list: [\n    { text: 'Learn TypeScript', done: true },\n    { text: 'Learn React', done: true },\n    { text: 'Learn Redux', done: false },\n  ],\n};\n"})}),"\n",(0,i.jsx)(t.p,{children:"If we were to use traditional immutable data updates, we might write it like this:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",children:"const nextState = {\n  ...state,\n  list: [\n    ...state.list.slice(0, 2),\n    {\n      ...state.list[2],\n      done: true,\n    },\n    { text: 'Learn Mutative', done: true },\n  ],\n};\n"})}),"\n",(0,i.jsx)(t.p,{children:"Using Mutative, we could write it like this:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",children:"import { create } from 'mutative';\n\nconst nextState = create(state, (draft) => {\n  draft.list[2].done = true;\n  draft.list.push({ text: 'Learn Mutative', done: true });\n});\n"})}),"\n",(0,i.jsx)(t.p,{children:"This is the basic usage of Mutative, which can help us implement immutable updates more simply."}),"\n",(0,i.jsx)(t.h2,{id:"motivation",children:"Motivation"}),"\n",(0,i.jsxs)(t.p,{children:["Immer helps us write simpler immutable updates with ",(0,i.jsx)(t.code,{children:"mutative"})," logic."]}),"\n",(0,i.jsx)(t.p,{children:"But its performance issue causes a runtime performance overhead. Immer must have auto-freeze enabled by default(Performance will be worse if auto-freeze is disabled), such immutable state with Immer is not common. In scenarios such as cross-processing, remote data transfer, etc., we have to constantly freeze these immutable data."}),"\n",(0,i.jsxs)(t.p,{children:["There are more parts that could be improved, such as better type inference, non-intrusive markup, support for more types of immutability, Safer immutability, ",(0,i.jsx)(t.a,{href:"https://github.com/unadlib/mutative/blob/main/test/immer-non-support.test.ts",children:"more edge cases"}),", and so on."]}),"\n",(0,i.jsx)(t.p,{children:"This is why Mutative was created."}),"\n",(0,i.jsx)(t.h2,{id:"features-and-benefits",children:"Features and Benefits"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Mutation makes immutable updates"})," - Immutable data structures supporting objects, arrays, Sets and Maps."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"High performance"})," - 10x faster than immer by default, even faster than naive handcrafted reducer."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Optional freezing state"})," - No freezing of immutable data by default."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Support for JSON Patch"})," - Full compliance with JSON Patch specification."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Custom shallow copy"})," - Support for more types of immutable data."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Support mark for immutable and mutable data"})," - Allows for non-invasive marking."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Safer mutable data access in strict mode"})," - It brings more secure immutable updates."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Support for reducer"})," - Support reducer function and any other immutable state library."]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"credits",children:"Credits"}),"\n",(0,i.jsxs)(t.p,{children:["Mutative is inspired by ",(0,i.jsx)(t.a,{href:"https://immerjs.github.io/immer/",children:"Immer"}),". It is a great library that has helped many people write simpler immutable updates. Mutative is based on the same idea, but it has a different implementation and more features."]})]})}function u(e={}){const{wrapper:t}={...(0,a.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},1151:(e,t,n)=>{n.d(t,{Z:()=>o,a:()=>s});var i=n(7294);const a={},r=i.createContext(a);function s(e){const t=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(r.Provider,{value:t},e.children)}}}]);