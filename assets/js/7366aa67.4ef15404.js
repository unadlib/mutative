"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[5502],{9390:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var a=n(5893),s=n(1151);const o={sidebar_position:2},r="apply()",i={id:"api-reference/apply",title:"apply()",description:"Use apply() for applying patches to get the new state.",source:"@site/docs/api-reference/apply.md",sourceDirName:"api-reference",slug:"/api-reference/apply",permalink:"/docs/api-reference/apply",draft:!1,unlisted:!1,editUrl:"https://github.com/unadlib/mutative/tree/main/website/docs/api-reference/apply.md",tags:[],version:"current",lastUpdatedBy:"unadlib",lastUpdatedAt:1747925555e3,sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"create()",permalink:"/docs/api-reference/create"},next:{title:"makeCreator()",permalink:"/docs/api-reference/makecreator"}},l={},c=[{value:"Usage",id:"usage",level:2},{value:"<code>apply(state, patches, options)</code>",id:"applystate-patches-options",level:3}];function p(e){const t={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,s.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h1,{id:"apply",children:"apply()"}),"\n",(0,a.jsxs)(t.p,{children:["Use ",(0,a.jsx)(t.code,{children:"apply()"})," for applying ",(0,a.jsx)(t.a,{href:"/docs/advanced-guides/pathes",children:"patches"})," to get the new state."]}),"\n",(0,a.jsx)(t.h2,{id:"usage",children:"Usage"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"import { create, apply } from 'mutative';\n\nconst baseState = {\n  foo: 'bar',\n  list: [{ text: 'todo' }],\n};\n\nconst [state, patches, inversePatches] = create(\n  baseState,\n  (draft) => {\n    draft.foo = 'foobar';\n    draft.list.push({ text: 'learning' });\n  },\n  {\n    enablePatches: true,\n  }\n);\n\n// you can apply patches to get the new state\nconst nextState = apply(baseState, patches);\n\nexpect(nextState).toEqual(state);\nconst prevState = apply(state, inversePatches);\nexpect(prevState).toEqual(baseState);\n"})}),"\n",(0,a.jsx)(t.h3,{id:"applystate-patches-options",children:(0,a.jsx)(t.code,{children:"apply(state, patches, options)"})}),"\n",(0,a.jsx)(t.p,{children:"The options parameter is optional and supports two types of configurations:"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:["Immutable options (similar to create options but without ",(0,a.jsx)(t.code,{children:"enablePatches"}),"):"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"strict"})," - ",(0,a.jsx)(t.code,{children:"boolean"}),", forbid accessing non-draftable values in strict mode"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"enableAutoFreeze"})," - ",(0,a.jsx)(t.code,{children:"boolean"}),", enable autoFreeze and return frozen state"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"mark"})," - mark function to determine if a value is mutable/immutable"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"const baseState = { foo: { bar: 'test' } };\n\n// This will create a new state.\nconst result = apply(baseState, [\n  {\n    op: 'replace',\n    path: ['foo', 'bar'],\n    value: 'test2',\n  },\n]);\nexpect(baseState).not.toEqual({ foo: { bar: 'test2' } });\nexpect(result).toEqual({ foo: { bar: 'test2' } });\n"})}),"\n",(0,a.jsxs)(t.ol,{start:"2",children:["\n",(0,a.jsxs)(t.li,{children:["Mutable option(Mutative v1.2.0+):","\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"mutable"})," - ",(0,a.jsx)(t.code,{children:"boolean"}),", if true the state will be mutated directly instead of creating a new state"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Example with mutable option:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"const baseState = { foo: { bar: 'test' } };\n\n// This will modify baseState directly\napply(\n  baseState,\n  [\n    {\n      op: 'replace',\n      path: ['foo', 'bar'],\n      value: 'test2',\n    },\n  ],\n  {\n    mutable: true,\n  }\n);\nexpect(baseState).toEqual({ foo: { bar: 'test2' } });\n"})}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:"\u26a0\ufe0fNote: The mutable option cannot be combined with other options. When using mutable option, apply() will return void instead of a new state."}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(p,{...e})}):p(e)}},1151:(e,t,n)=>{n.d(t,{Z:()=>i,a:()=>r});var a=n(7294);const s={},o=a.createContext(s);function r(e){const t=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),a.createElement(o.Provider,{value:t},e.children)}}}]);