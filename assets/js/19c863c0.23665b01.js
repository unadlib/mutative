"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3829],{4435:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>i,default:()=>u,frontMatter:()=>s,metadata:()=>o,toc:()=>c});var a=n(5893),r=n(1151);const s={sidebar_position:2},i="Marking data structure",o={id:"advanced-guides/mark",title:"Marking data structure",description:"Mark options provides additional controls or flags to determine immutability or mutability of data nodes in drafts function execution process, or customize shallow copy for creating drafts.",source:"@site/docs/advanced-guides/mark.md",sourceDirName:"advanced-guides",slug:"/advanced-guides/mark",permalink:"/docs/advanced-guides/mark",draft:!1,unlisted:!1,editUrl:"https://github.com/unadlib/mutative/tree/main/website/docs/advanced-guides/mark.md",tags:[],version:"current",lastUpdatedBy:"unadlib",lastUpdatedAt:170222723e4,sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Currying",permalink:"/docs/advanced-guides/currying"},next:{title:"Auto Freeze",permalink:"/docs/advanced-guides/auto-freeze"}},d={},c=[{value:"Customize mark",id:"customize-mark",level:2}];function l(e){const t={admonition:"admonition",code:"code",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h1,{id:"marking-data-structure",children:"Marking data structure"}),"\n",(0,a.jsxs)(t.p,{children:["Mark options provides additional controls or flags to determine ",(0,a.jsx)(t.code,{children:"immutability"})," or ",(0,a.jsx)(t.code,{children:"mutability"})," of data nodes in drafts function execution process, or ",(0,a.jsx)(t.code,{children:"customize shallow copy"})," for creating drafts."]}),"\n",(0,a.jsx)(t.h2,{id:"customize-mark",children:"Customize mark"}),"\n",(0,a.jsxs)(t.p,{children:["Mark options are a set of configurations that dictate how the ",(0,a.jsx)(t.code,{children:"immutable"})," or ",(0,a.jsx)(t.code,{children:"mutable"})," handles state during the drafting and updating process. These options offer developers more control and flexibility in managing state changes, allowing for customized behavior based on the specific requirements of the application."]}),"\n",(0,a.jsx)(t.p,{children:"Key aspects of mark options include:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Customizable State Management"}),": Mark options enable developers to tailor the state management process. This includes defining how state changes are tracked, how drafts are created about shallow copy, and how changes are finalized."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Enhanced Flexibility"}),": Mark options support array marking, which allows for more granular and composable control over state updates. This is particularly useful in scenarios where different parts of the state might require different handling."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Non-invasive marking"}),": Mark options are designed to be non-invasive, meaning that they do not affect the state itself. This ensures that the state remains unaltered and can be safely accessed at any time."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"class FooBar {\n  constructor(public bar?: string) {}\n}\n\nconst bar = {\n  bar: 'str',\n};\n\nconst baseState = {\n  bar,\n  date: new Date(0),\n  fooBar: new FooBar('str'),\n};\n\nconst nextState = create(\n  baseState,\n  (draft) => {\n    draft.date.setFullYear(2000);\n    draft.bar.bar = 'new str';\n    draft.fooBar.bar = 'new str';\n  },\n  {\n    mark: (target, { mutable, immutable }) => {\n      if (target instanceof Date) return () => new Date(target.getTime());\n      if (target === bar) return mutable;\n      if (target instanceof FooBar) return immutable;\n    },\n  }\n);\nexpect(nextState).not.toBe(baseState);\nexpect(nextState.bar).toBe(baseState.bar);\nexpect(nextState.date).not.toBe(baseState.date);\nexpect(nextState.fooBar).not.toBe(baseState.fooBar);\n"})}),"\n",(0,a.jsx)(t.admonition,{type:"tip",children:(0,a.jsx)(t.p,{children:"Set a mark to determine if the value is mutable or if an instance is an immutable, and it can also return a shallow copy function(AutoFreeze and Patches should both be disabled, Some patches operation might not be equivalent). When the mark function is (target) => 'immutable', it means all the objects in the state structure are immutable. In this specific case, you can totally turn on AutoFreeze and Patches. mark supports multiple marks, and the marks are executed in order, and the first mark that returns a value will be used."})})]})}function u(e={}){const{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},1151:(e,t,n)=>{n.d(t,{Z:()=>o,a:()=>i});var a=n(7294);const r={},s=a.createContext(r);function i(e){const t=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),a.createElement(s.Provider,{value:t},e.children)}}}]);