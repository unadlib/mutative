"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[7182],{8978:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>d,contentTitle:()=>i,default:()=>u,frontMatter:()=>s,metadata:()=>c,toc:()=>o});var a=r(5893),n=r(1151);const s={sidebar_position:5},i="Performance",c={id:"getting-started/performance",title:"Performance",description:"Mutative is a high-performance immutable data structure library, it is up to 2x-6x faster than naive handcrafted reducer and up to 16x faster than Immer.",source:"@site/docs/getting-started/performance.md",sourceDirName:"getting-started",slug:"/getting-started/performance",permalink:"/docs/getting-started/performance",draft:!1,unlisted:!1,editUrl:"https://github.com/unadlib/mutative/tree/main/website/docs/getting-started/performance.md",tags:[],version:"current",lastUpdatedBy:"unadlib",lastUpdatedAt:1732299311e3,sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Using Mutative with React",permalink:"/docs/getting-started/mutative-with-react"},next:{title:"Advanced Guides",permalink:"/docs/category/advanced-guides"}},d={},o=[{value:"Mutative vs Reducer Performance",id:"mutative-vs-reducer-performance",level:2},{value:"Reducer by object",id:"reducer-by-object",level:3},{value:"Reducer by array",id:"reducer-by-array",level:3},{value:"Mutative vs Immer Performance",id:"mutative-vs-immer-performance",level:2},{value:"More Performance Testing Scenarios",id:"more-performance-testing-scenarios",level:2}];function l(e){const t={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,n.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h1,{id:"performance",children:"Performance"}),"\n",(0,a.jsxs)(t.p,{children:["Mutative is a high-performance immutable data structure library, it is up to ",(0,a.jsx)(t.code,{children:"2x-6x"})," faster than naive handcrafted reducer and up to ",(0,a.jsx)(t.code,{children:"16x"})," faster than Immer."]}),"\n",(0,a.jsx)(t.h2,{id:"mutative-vs-reducer-performance",children:"Mutative vs Reducer Performance"}),"\n",(0,a.jsx)(t.h3,{id:"reducer-by-object",children:"Reducer by object"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Naive handcrafted reducer"}),"\n"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"// baseState type: Record<string, { value: number }>\nconst state = {\n  ...baseState,\n  key0: {\n    ...baseState.key0,\n    value: i,\n  },\n};\n"})}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Mutative"}),"\n"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"const state = create(baseState, (draft) => {\n  draft.key0.value = i;\n});\n"})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Mutative vs Reducer benchmark by object",src:r(8855).Z+"",width:"1000",height:"600"})}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsxs)(t.p,{children:["Measure(seconds) to update the 1K-100K items object, lower is better(",(0,a.jsx)(t.a,{href:"https://github.com/unadlib/mutative/blob/main/test/performance/benchmark-object.ts",children:"view source"}),")."]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsxs)(t.strong,{children:["Mutative is up to ",(0,a.jsx)(t.code,{children:"2x"})," faster than naive handcrafted reducer for updating immutable objects."]})}),"\n",(0,a.jsx)(t.h3,{id:"reducer-by-array",children:"Reducer by array"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Naive handcrafted reducer"}),"\n"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"// baseState type: { value: number }[]\n\n// slower 6x than Mutative\nconst state = [\n  { ...baseState[0], value: i },\n  ...baseState.slice(1, baseState.length),\n];\n\n// slower 2.5x than Mutative\n// const state = baseState.map((item, index) =>\n//   index === 0 ? { ...item, value: i } : item\n// );\n\n// same performance as Mutative\n// const state = [...baseState];\n// state[0] = { ...baseState[0], value: i };\n"})}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:"The actual difference depends on which spread operation syntax you use."}),"\n"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Mutative"}),"\n"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"const state = create(baseState, (draft) => {\n  draft[0].value = i;\n});\n"})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Mutative vs Reducer benchmark by array",src:r(4119).Z+"",width:"1000",height:"600"})}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsxs)(t.p,{children:["Measure(seconds) to update the 1K-100K items array, lower is better(",(0,a.jsx)(t.a,{href:"https://github.com/unadlib/mutative/blob/main/test/performance/benchmark-array.ts",children:"view source"}),")."]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsxs)(t.strong,{children:["Mutative is up to ",(0,a.jsx)(t.code,{children:"6x"})," faster than naive handcrafted reducer for updating immutable arrays."]})}),"\n",(0,a.jsx)(t.h2,{id:"mutative-vs-immer-performance",children:"Mutative vs Immer Performance"}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:"Mutative passed all of Immer's test cases."}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["Measure(ops/sec) to update 50K arrays and 1K objects, bigger is better(",(0,a.jsx)(t.a,{href:"https://github.com/unadlib/mutative/blob/main/test/performance/benchmark.ts",children:"view source"}),"). [Mutative v1.1.0 vs Immer v10.1.1]"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Benchmark",src:r(3578).Z+"",width:"1000",height:"600"})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"Naive handcrafted reducer - No Freeze x 4,670 ops/sec \xb10.64% (96 runs sampled)\nMutative - No Freeze x 6,747 ops/sec \xb10.61% (95 runs sampled)\nImmer - No Freeze x 5.65 ops/sec \xb11.53% (19 runs sampled)\n\nMutative - Freeze x 1,062 ops/sec \xb10.74% (95 runs sampled)\nImmer - Freeze x 394 ops/sec \xb10.85% (93 runs sampled)\n\nMutative - Patches and No Freeze x 1,011 ops/sec \xb10.24% (98 runs sampled)\nImmer - Patches and No Freeze x 5.64 ops/sec \xb10.22% (19 runs sampled)\n\nMutative - Patches and Freeze x 545 ops/sec \xb11.19% (94 runs sampled)\nImmer - Patches and Freeze x 215 ops/sec \xb10.70% (86 runs sampled)\n\nThe fastest method is Mutative - No Freeze\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Run ",(0,a.jsx)(t.code,{children:"yarn benchmark"})," to measure performance."]}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:"OS: macOS 14.7, CPU: Apple M1 Max, Node.js: v22.11.0"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Immer relies on auto-freeze to be enabled, if auto-freeze is disabled, Immer will have a huge performance drop and Mutative will have a huge performance lead, especially with large data structures it will have a performance lead of more than 50x."}),"\n",(0,a.jsxs)(t.p,{children:["So if you are using Immer, you will have to enable auto-freeze for performance. Mutative is disabled auto-freeze by default. With the default configuration of both, we can see the 17x performance gap between Mutative (",(0,a.jsx)(t.code,{children:"6,747 ops/sec"}),") and Immer (",(0,a.jsx)(t.code,{children:"394 ops/sec"}),")."]}),"\n",(0,a.jsxs)(t.p,{children:["Overall, Mutative has a huge performance lead over Immer in ",(0,a.jsx)(t.a,{href:"https://github.com/unadlib/mutative/tree/main/test/performance",children:"more performance testing scenarios"}),". Run ",(0,a.jsx)(t.code,{children:"yarn performance"})," to get all the performance results locally."]}),"\n",(0,a.jsx)(t.h2,{id:"more-performance-testing-scenarios",children:"More Performance Testing Scenarios"}),"\n",(0,a.jsxs)(t.p,{children:["Mutative is up to ",(0,a.jsx)(t.code,{children:"2.5X-82.9X"})," faster than Immer:"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Mutative vs Immer - All benchmark results by average multiplier",src:r(6068).Z+"",width:"1000",height:"600"})}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.a,{href:"https://github.com/unadlib/mutative/blob/main/test/benchmark",children:"view source"}),"."]}),"\n"]})]})}function u(e={}){const{wrapper:t}={...(0,n.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},6068:(e,t,r)=>{r.d(t,{Z:()=>a});const a=r.p+"assets/images/all-1e5b3bdcb7c83f6fc8ce525634c10402.jpg"},4119:(e,t,r)=>{r.d(t,{Z:()=>a});const a=r.p+"assets/images/benchmark-array-53267be71341564a59ab3e798f0da594.jpg"},8855:(e,t,r)=>{r.d(t,{Z:()=>a});const a=r.p+"assets/images/benchmark-object-d20dc0c6f7df5ee5641847a9a8b8a3ea.jpg"},3578:(e,t,r)=>{r.d(t,{Z:()=>a});const a=r.p+"assets/images/benchmark-38031f1ff8d9b82ebf0bfcdb45fc9972.jpg"},1151:(e,t,r)=>{r.d(t,{Z:()=>c,a:()=>i});var a=r(7294);const n={},s=a.createContext(n);function i(e){const t=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:i(e.components),a.createElement(s.Provider,{value:t},e.children)}}}]);