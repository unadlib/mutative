"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4],{6943:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>c,toc:()=>l});var a=t(5893),s=t(1151);const i={sidebar_position:1},r="Patches",c={id:"advanced-guides/pathes",title:"Patches",description:"Enable patch, and return the patches and inversePatches.",source:"@site/docs/advanced-guides/pathes.md",sourceDirName:"advanced-guides",slug:"/advanced-guides/pathes",permalink:"/docs/advanced-guides/pathes",draft:!1,unlisted:!1,editUrl:"https://github.com/unadlib/mutative/tree/main/website/docs/advanced-guides/pathes.md",tags:[],version:"current",lastUpdatedBy:"unadlib",lastUpdatedAt:170222723e4,sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Advanced Guides",permalink:"/docs/category/advanced-guides"},next:{title:"Currying",permalink:"/docs/advanced-guides/currying"}},o={},l=[{value:"Enable patches",id:"enable-patches",level:2},{value:"JSON patches",id:"json-patches",level:2},{value:"pathAsArray - default: true",id:"pathasarray---default-true",level:3},{value:"arrayLengthAssignment - default: true",id:"arraylengthassignment---default-true",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h1,{id:"patches",children:"Patches"}),"\n",(0,a.jsxs)(n.p,{children:["Enable patch, and return the ",(0,a.jsx)(n.code,{children:"patches"})," and ",(0,a.jsx)(n.code,{children:"inversePatches"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"enable-patches",children:"Enable patches"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"boolean | { pathAsArray?: boolean; arrayLengthAssignment?: boolean; }"}),", the default is false."]}),"\n",(0,a.jsxs)(n.p,{children:["If you need to set the shape of the generated patch in more detail, then you can set ",(0,a.jsx)(n.code,{children:"pathAsArray"})," and ",(0,a.jsx)(n.code,{children:"arrayLengthAssignment"}),"\u3002",(0,a.jsx)(n.code,{children:"pathAsArray"})," default value is ",(0,a.jsx)(n.code,{children:"true"}),", if it's ",(0,a.jsx)(n.code,{children:"true"}),", the path will be an array, otherwise it is a string; ",(0,a.jsx)(n.code,{children:"arrayLengthAssignment"})," default value is ",(0,a.jsx)(n.code,{children:"true"}),", if it's ",(0,a.jsx)(n.code,{children:"true"}),", the array length will be included in the patches, otherwise no include array length, ",(0,a.jsx)(n.a,{href:"https://github.com/unadlib/mutative/issues/6",children:"view related discussions"}),". It support any immutable data structure, such as object, array, ",(0,a.jsx)(n.code,{children:"Map"}),", ",(0,a.jsx)(n.code,{children:"Set"}),", custom immutable data structure(",(0,a.jsx)(n.code,{children:"Need to pass apply() mark function"}),"), etc."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:'import { create, apply } from \'mutative\';\n\nconst baseState = {\n  foo: \'bar\',\n  list: [{ text: \'todo\' }],\n};\n\nconst [state, patches, inversePatches] = create(\n  baseState,\n  (draft) => {\n    draft.foo = \'foobar\';\n    draft.list.push({ text: \'learning\' });\n  },\n  {\n    enablePatches: true,\n  }\n);\n\nconst nextState = apply(baseState, patches);\nexpect(nextState).toEqual(state);\nconst prevState = apply(state, inversePatches);\nexpect(prevState).toEqual(baseState);\nexpect(patches).toMatchInlineSnapshot(`\n    [\n      {\n        "op": "add",\n        "path": [\n          "list",\n          1,\n        ],\n        "value": {\n          "text": "learning",\n        },\n      },\n      {\n        "op": "replace",\n        "path": [\n          "foo",\n        ],\n        "value": "foobar",\n      },\n    ]\n  `);\nexpect(inversePatches).toMatchInlineSnapshot(`\n    [\n      {\n        "op": "replace",\n        "path": [\n          "list",\n          "length",\n        ],\n        "value": 1,\n      },\n      {\n        "op": "replace",\n        "path": [\n          "foo",\n        ],\n        "value": "bar",\n      },\n    ]\n  `);\n'})}),"\n",(0,a.jsx)(n.h2,{id:"json-patches",children:"JSON patches"}),"\n",(0,a.jsx)(n.p,{children:"Mutative integrates JSON Patch functionality to enhance its state management capabilities. This integration allows Mutative to generate and apply a sequence of operations (patches) that describe changes made to a JSON object. JSON Patch is particularly useful in scenarios where tracking changes to state in a detailed and structured manner is important, such as in synchronization tasks or when maintaining historical records of state changes."}),"\n",(0,a.jsx)(n.p,{children:"Key features of JSON Patch in Mutative include:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Efficient Change Tracking"}),": JSON Patch provides a way to represent changes in a compact, easy-to-understand format. This is crucial for applications that need to track state changes over time or communicate these changes across different parts of an application or network."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Reversibility"}),": With JSON Patch, you can generate inverse patches, allowing you to revert to previous states if needed. This can be invaluable for undo/redo functionality or for correcting erroneous state changes."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Interoperability"}),": JSON Patch is a standard format, making it compatible with a wide range of tools and libraries that also use or understand JSON Patch. This enhances Mutative's ability to integrate with other systems and technologies."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Precise State Modifications"}),": Mutative's implementation of JSON Patch can handle complex changes, including modifications to nested structures and arrays, ensuring that even detailed and nuanced state changes are accurately captured and can be reproduced."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"In summary, the integration of JSON Patch into Mutative adds a layer of precision and clarity to state management, allowing developers to have a clear and structured record of how the state evolves over time. This makes it an invaluable tool for complex applications that require meticulous state tracking and manipulation."}),"\n",(0,a.jsx)(n.h3,{id:"pathasarray---default-true",children:"pathAsArray - default: true"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:'const data = { list: [1, 2, 3] };\nconst [state, patches, inversePatches] = create(\n  data,\n  (draft) => {\n    draft.list.length = 0;\n  },\n  {\n    enablePatches: {\n      pathAsArray: false,\n      arrayLengthAssignment: true,\n    },\n  }\n);\nexpect(state).toMatchInlineSnapshot(`\n    {\n      "list": [],\n    }\n  `);\nexpect(patches).toMatchInlineSnapshot(`\n    [\n      {\n        "op": "replace",\n        "path": "/list/length",\n        "value": 0,\n      },\n    ]\n  `);\nexpect(inversePatches).toMatchInlineSnapshot(`\n    [\n      {\n        "op": "add",\n        "path": "/list/0",\n        "value": 1,\n      },\n      {\n        "op": "add",\n        "path": "/list/1",\n        "value": 2,\n      },\n      {\n        "op": "add",\n        "path": "/list/2",\n        "value": 3,\n      },\n    ]\n  `);\n'})}),"\n",(0,a.jsx)(n.h3,{id:"arraylengthassignment---default-true",children:"arrayLengthAssignment - default: true"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:'const data = { list: [1, 2, 3] };\nconst [state, patches, inversePatches] = create(\n  data,\n  (draft) => {\n    draft.list.length = 0;\n  },\n  {\n    enablePatches: {\n      pathAsArray: true,\n      arrayLengthAssignment: false,\n    },\n  }\n);\nexpect(state).toMatchInlineSnapshot(`\n    {\n      "list": [],\n    }\n  `);\nexpect(patches).toMatchInlineSnapshot(`\n    [\n      {\n        "op": "remove",\n        "path": [\n          "list",\n          2,\n        ],\n      },\n      {\n        "op": "remove",\n        "path": [\n          "list",\n          1,\n        ],\n      },\n      {\n        "op": "remove",\n        "path": [\n          "list",\n          0,\n        ],\n      },\n    ]\n  `);\nexpect(inversePatches).toMatchInlineSnapshot(`\n    [\n      {\n        "op": "add",\n        "path": [\n          "list",\n          0,\n        ],\n        "value": 1,\n      },\n      {\n        "op": "add",\n        "path": [\n          "list",\n          1,\n        ],\n        "value": 2,\n      },\n      {\n        "op": "add",\n        "path": [\n          "list",\n          2,\n        ],\n        "value": 3,\n      },\n    ]\n  `);\n'})}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsxs)(n.p,{children:["If ",(0,a.jsx)(n.code,{children:"arrayLengthAssignment"})," is ",(0,a.jsx)(n.code,{children:"false"}),", it is fully compatible with JSON Patch spec, but it may have additional performance loss."]})})]})}function h(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>c,a:()=>r});var a=t(7294);const s={},i=a.createContext(s);function r(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);