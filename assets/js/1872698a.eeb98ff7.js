"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[7182],{8978:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>d,contentTitle:()=>c,default:()=>u,frontMatter:()=>s,metadata:()=>i,toc:()=>o});var a=r(5893),n=r(1151);const s={sidebar_position:5},c="Performance",i={id:"getting-started/performance",title:"Performance",description:"Mutative is a high-performance immutable data structure library, it is up to 2x-6x faster than naive handcrafted reducer and up to 16x faster than Immer.",source:"@site/docs/getting-started/performance.md",sourceDirName:"getting-started",slug:"/getting-started/performance",permalink:"/docs/getting-started/performance",draft:!1,unlisted:!1,editUrl:"https://github.com/unadlib/mutative/tree/main/website/docs/getting-started/performance.md",tags:[],version:"current",lastUpdatedBy:"unadlib",lastUpdatedAt:1713517564e3,sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Using Mutative with React",permalink:"/docs/getting-started/mutative-with-react"},next:{title:"Advanced Guides",permalink:"/docs/category/advanced-guides"}},d={},o=[{value:"Mutative vs Reducer Performance",id:"mutative-vs-reducer-performance",level:2},{value:"Reducer by object",id:"reducer-by-object",level:3},{value:"Reducer by array",id:"reducer-by-array",level:3},{value:"Mutative vs Immer Performance",id:"mutative-vs-immer-performance",level:2}];function l(e){const t={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,n.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h1,{id:"performance",children:"Performance"}),"\n",(0,a.jsxs)(t.p,{children:["Mutative is a high-performance immutable data structure library, it is up to ",(0,a.jsx)(t.code,{children:"2x-6x"})," faster than naive handcrafted reducer and up to ",(0,a.jsx)(t.code,{children:"16x"})," faster than Immer."]}),"\n",(0,a.jsx)(t.h2,{id:"mutative-vs-reducer-performance",children:"Mutative vs Reducer Performance"}),"\n",(0,a.jsx)(t.h3,{id:"reducer-by-object",children:"Reducer by object"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Naive handcrafted reducer"}),"\n"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"// baseState type: Record<string, { value: number }>\nconst state = {\n  ...baseState,\n  key0: {\n    ...baseState.key0,\n    value: i,\n  },\n};\n"})}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Mutative"}),"\n"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"const state = create(baseState, (draft) => {\n  draft.key0.value = i;\n});\n"})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Mutative vs Reducer benchmark by object",src:r(8855).Z+"",width:"1000",height:"600"})}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsxs)(t.p,{children:["Measure(seconds) to update the 1K-100K items object, lower is better(",(0,a.jsx)(t.a,{href:"https://github.com/unadlib/mutative/blob/main/test/performance/benchmark-object.ts",children:"view source"}),")."]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsxs)(t.strong,{children:["Mutative is up to ",(0,a.jsx)(t.code,{children:"2x"})," faster than naive handcrafted reducer for updating immutable objects."]})}),"\n",(0,a.jsx)(t.h3,{id:"reducer-by-array",children:"Reducer by array"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Naive handcrafted reducer"}),"\n"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"// baseState type: { value: number }[]\nconst state = [\n  { ...baseState[0], value: i },\n  ...baseState.slice(1, baseState.length),\n];\n"})}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Mutative"}),"\n"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"const state = create(baseState, (draft) => {\n  draft[0].value = i;\n});\n"})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Mutative vs Reducer benchmark by array",src:r(4119).Z+"",width:"1000",height:"600"})}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsxs)(t.p,{children:["Measure(seconds) to update the 1K-100K items array, lower is better(",(0,a.jsx)(t.a,{href:"https://github.com/unadlib/mutative/blob/main/test/performance/benchmark-array.ts",children:"view source"}),")."]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsxs)(t.strong,{children:["Mutative is up to ",(0,a.jsx)(t.code,{children:"6x"})," faster than naive handcrafted reducer for updating immutable arrays."]})}),"\n",(0,a.jsx)(t.h2,{id:"mutative-vs-immer-performance",children:"Mutative vs Immer Performance"}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:"Mutative passed all of Immer's test cases."}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["Measure(ops/sec) to update 50K arrays and 1K objects, bigger is better(",(0,a.jsx)(t.a,{href:"https://github.com/unadlib/mutative/blob/main/test/performance/benchmark.ts",children:"view source"}),"). [Mutative v1.0.5 vs Immer v10.0.4]"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Benchmark",src:r(3578).Z+"",width:"1000",height:"600"})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"Naive handcrafted reducer - No Freeze x 4,442 ops/sec \xb10.49% (94 runs sampled)\nMutative - No Freeze x 6,101 ops/sec \xb11.26% (88 runs sampled)\nImmer - No Freeze x 5.20 ops/sec \xb10.68% (17 runs sampled)\n\nMutative - Freeze x 946 ops/sec \xb11.36% (92 runs sampled)\nImmer - Freeze x 376 ops/sec \xb11.10% (93 runs sampled)\n\nMutative - Patches and No Freeze x 963 ops/sec \xb11.14% (96 runs sampled)\nImmer - Patches and No Freeze x 5.32 ops/sec \xb10.21% (18 runs sampled)\n\nMutative - Patches and Freeze x 501 ops/sec \xb11.24% (93 runs sampled)\nImmer - Patches and Freeze x 272 ops/sec \xb10.61% (88 runs sampled)\n\nThe fastest method is Mutative - No Freeze\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Run ",(0,a.jsx)(t.code,{children:"yarn benchmark"})," to measure performance."]}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:"OS: macOS 14.2.1, CPU: Apple M1 Max, Node.js: v20.11.0"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Immer relies on auto-freeze to be enabled, if auto-freeze is disabled, Immer will have a huge performance drop and Mutative will have a huge performance lead, especially with large data structures it will have a performance lead of more than 50x."}),"\n",(0,a.jsxs)(t.p,{children:["So if you are using Immer, you will have to enable auto-freeze for performance. Mutative is disabled auto-freeze by default. With the default configuration of both, we can see the 16x performance gap between Mutative (",(0,a.jsx)(t.code,{children:"6,058 ops/sec"}),") and Immer (",(0,a.jsx)(t.code,{children:"380 ops/sec"}),")."]}),"\n",(0,a.jsxs)(t.p,{children:["Overall, Mutative has a huge performance lead over Immer in ",(0,a.jsx)(t.a,{href:"https://github.com/unadlib/mutative/tree/main/test/performance",children:"more performance testing scenarios"}),". Run ",(0,a.jsx)(t.code,{children:"yarn performance"})," to get all the performance results locally."]})]})}function u(e={}){const{wrapper:t}={...(0,n.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},4119:(e,t,r)=>{r.d(t,{Z:()=>a});const a=r.p+"assets/images/benchmark-array-b8836c6de27252cc4fc9f7bfc10bd597.jpg"},8855:(e,t,r)=>{r.d(t,{Z:()=>a});const a=r.p+"assets/images/benchmark-object-6e91751730902877eb71d7659da3c973.jpg"},3578:(e,t,r)=>{r.d(t,{Z:()=>a});const a=r.p+"assets/images/benchmark-8651b1e167c5ad548693d4df013b0695.jpg"},1151:(e,t,r)=>{r.d(t,{Z:()=>i,a:()=>c});var a=r(7294);const n={},s=a.createContext(n);function c(e){const t=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:c(e.components),a.createElement(s.Provider,{value:t},e.children)}}}]);