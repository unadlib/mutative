"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[9451],{5822:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>l,frontMatter:()=>a,metadata:()=>i,toc:()=>c});var n=r(5893),s=r(1151);const a={sidebar_position:4,title:"Shared References"},o="Shared References Behavior",i={id:"extra-topics/shared-references",title:"Shared References",description:"Mutative supports non-unidirectional trees (DAGs with shared nodes) where there is more than one path from the root to the same node, as long as there are no cycles. However, there is an important behavior to understand regarding how drafts handle these shared references.",source:"@site/docs/extra-topics/shared-references.md",sourceDirName:"extra-topics",slug:"/extra-topics/shared-references",permalink:"/docs/extra-topics/shared-references",draft:!1,unlisted:!1,editUrl:"https://github.com/unadlib/mutative/tree/main/website/docs/extra-topics/shared-references.md",tags:[],version:"current",lastUpdatedBy:"unadlib",lastUpdatedAt:1767419746e3,sidebarPosition:4,frontMatter:{sidebar_position:4,title:"Shared References"},sidebar:"tutorialSidebar",previous:{title:"Mutative Ecosystem",permalink:"/docs/extra-topics/mutative-ecosystem"}},d={},c=[{value:"Independent Drafts for Multiple Paths",id:"independent-drafts-for-multiple-paths",level:2},{value:"Creating Shared References",id:"creating-shared-references",level:2},{value:"Summary",id:"summary",level:2}];function h(e){const t={code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,s.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"shared-references-behavior",children:"Shared References Behavior"}),"\n",(0,n.jsxs)(t.p,{children:["Mutative supports non-unidirectional trees (DAGs with shared nodes) where there is more than one path from the root to the same node, ",(0,n.jsx)(t.strong,{children:"as long as there are no cycles"}),". However, there is an important behavior to understand regarding how drafts handle these shared references."]}),"\n",(0,n.jsx)(t.h2,{id:"independent-drafts-for-multiple-paths",children:"Independent Drafts for Multiple Paths"}),"\n",(0,n.jsxs)(t.p,{children:["When the same object is referenced from multiple paths in the base state, Mutative creates ",(0,n.jsx)(t.strong,{children:"independent drafts for each path"}),". This means modifications to one path will ",(0,n.jsx)(t.strong,{children:"not"})," automatically reflect in the other paths."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-javascript",children:"import { create } from 'mutative';\n\nconst obj = {};\n// Same object referenced by two keys\nobj.color1 = obj.color2 = { name: 'Red' };\n\nconst result = create(obj, (draft) => {\n  // \u26a0\ufe0f Different drafts created for each path!\n  console.log(draft.color1 === draft.color2); // false\n\n  draft.color1.name = 'Blue';\n  \n  // color2 remains unchanged because it has a separate draft\n  console.log(draft.color2.name); // 'Red'\n});\n\nconsole.log(result.color1 === result.color2); // false\n// Result: { color1: { name: 'Blue' }, color2: { name: 'Red' } }\n"})}),"\n",(0,n.jsxs)(t.p,{children:["This behavior is ",(0,n.jsx)(t.strong,{children:"by design"})," and matches Immer's behavior. Each path through the state tree gets its own independent draft proxy."]}),"\n",(0,n.jsx)(t.h2,{id:"creating-shared-references",children:"Creating Shared References"}),"\n",(0,n.jsxs)(t.p,{children:["If you need to ",(0,n.jsx)(t.strong,{children:"preserve or create shared references"})," in the result state, you must do so explicitly within your recipe function by assigning one draft to another."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-javascript",children:"const result = create(obj, (draft) => {\n  draft.color1.name = 'Blue';\n  \n  // \u2705 Explicitly share the reference\n  draft.color2 = draft.color1;\n});\n\n// Now they share the same reference in the result\nconsole.log(result.color1 === result.color2); // true\n// Result: { color1: { name: 'Blue' }, color2: { name: 'Blue' } }\n"})}),"\n",(0,n.jsx)(t.h2,{id:"summary",children:"Summary"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Scenario"}),(0,n.jsx)(t.th,{children:"Behavior"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.strong,{children:"Shared nodes in base state"})}),(0,n.jsxs)(t.td,{children:["Each path gets its own ",(0,n.jsx)(t.strong,{children:"independent draft"}),". Mutations through one path do ",(0,n.jsx)(t.strong,{children:"not"})," reflect in other paths."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.strong,{children:"Manually assigned references"})}),(0,n.jsxs)(t.td,{children:["\u2705 ",(0,n.jsx)(t.strong,{children:"Supported"}),". Assigning ",(0,n.jsx)(t.code,{children:"draft.x = draft.y"})," creates shared references in the final state."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.strong,{children:"Real cycles"})}),(0,n.jsxs)(t.td,{children:["\u274c ",(0,n.jsx)(t.strong,{children:"Not supported"}),". Cycles are actively detected in development mode when auto-freeze is enabled."]})]})]})]})]})}function l(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},1151:(e,t,r)=>{r.d(t,{Z:()=>i,a:()=>o});var n=r(7294);const s={},a=n.createContext(s);function o(e){const t=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),n.createElement(a.Provider,{value:t},e.children)}}}]);