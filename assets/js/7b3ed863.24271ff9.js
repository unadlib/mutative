"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2657],{1679:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>r,contentTitle:()=>c,default:()=>l,frontMatter:()=>i,metadata:()=>o,toc:()=>d});var n=a(5893),s=a(1151);const i={sidebar_position:3},c="Concepts",o={id:"getting-started/concepts",title:"Concepts",description:"Mutative is based on the Proxy, its core concepts are draft and patch.",source:"@site/docs/getting-started/concepts.md",sourceDirName:"getting-started",slug:"/getting-started/concepts",permalink:"/docs/getting-started/concepts",draft:!1,unlisted:!1,editUrl:"https://github.com/unadlib/mutative/tree/main/website/docs/getting-started/concepts.md",tags:[],version:"current",lastUpdatedBy:"unadlib",lastUpdatedAt:1701961455,formattedLastUpdatedAt:"Dec 7, 2023",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Usages",permalink:"/docs/getting-started/usages"},next:{title:"Using Mutative with React",permalink:"/docs/getting-started/mutative-with-react"}},r={},d=[{value:"Drafts",id:"drafts",level:2},{value:"Patches",id:"patches",level:2},{value:"Mark",id:"mark",level:2}];function h(e){const t={code:"code",h1:"h1",h2:"h2",p:"p",...(0,s.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"concepts",children:"Concepts"}),"\n",(0,n.jsxs)(t.p,{children:["Mutative is based on the Proxy, its core concepts are ",(0,n.jsx)(t.code,{children:"draft"})," and ",(0,n.jsx)(t.code,{children:"patch"}),"."]}),"\n",(0,n.jsx)(t.h2,{id:"drafts",children:"Drafts"}),"\n",(0,n.jsx)(t.p,{children:"Using Mutative to produce a new immutable data(next state)."}),"\n",(0,n.jsxs)(t.p,{children:["Mutative creates a draft copy. The ",(0,n.jsx)(t.code,{children:"draft"})," is a mutable ",(0,n.jsx)(t.code,{children:"Proxy"})," object, which behaves the same as the original object. Those mutations are recorded and used to produce the next state once the draft function is done. Additionally, if the patches is enabled, it will also produce a ",(0,n.jsx)(t.code,{children:"patches"}),"."]}),"\n",(0,n.jsx)(t.h2,{id:"patches",children:"Patches"}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"Patches"})," are operation patches for immutable updates, consisting of an array where each element is a ",(0,n.jsx)(t.code,{children:"Patch"}),". A ",(0,n.jsx)(t.code,{children:"Patch"})," is an object that contains a ",(0,n.jsx)(t.code,{children:"path"}),", a ",(0,n.jsx)(t.code,{children:"value"}),", and an ",(0,n.jsx)(t.code,{children:"op"}),". The ",(0,n.jsx)(t.code,{children:"path"})," is an array representing the path to an object; the ",(0,n.jsx)(t.code,{children:"value"})," is a new value for the object; and ",(0,n.jsx)(t.code,{children:"op"})," is a string representing the type of operation, which can be ",(0,n.jsx)(t.code,{children:"add"}),", ",(0,n.jsx)(t.code,{children:"remove"}),", or ",(0,n.jsx)(t.code,{children:"replace"}),"."]}),"\n",(0,n.jsxs)(t.p,{children:["By applying ",(0,n.jsx)(t.code,{children:"patches"}),", immutable updates can be made to an object based on these patches. These patches enable immutable updates without modifying the original object, acting as instructions for the update process."]}),"\n",(0,n.jsx)(t.h2,{id:"mark",children:"Mark"}),"\n",(0,n.jsx)(t.p,{children:"If a data structure mixes mutable and immutable data, Mutative supports marking both immutable and mutable data. It allows for non-invasive marking of nodes within this data tree, meaning the original object structure does not require an additional marking symbol. Mutative can maintain the original characteristics of the structure tree's nodes."}),"\n",(0,n.jsxs)(t.p,{children:["It is used to mark the immutable data that needs to be updated, and the mutable data that needs to be accessed. You pass the ",(0,n.jsx)(t.code,{children:"mark"})," option to ",(0,n.jsx)(t.code,{children:"create()"})," to mark the immutable data."]})]})}function l(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},1151:(e,t,a)=>{a.d(t,{Z:()=>o,a:()=>c});var n=a(7294);const s={},i=n.createContext(s);function c(e){const t=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);