"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[7182],{8978:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>d,contentTitle:()=>i,default:()=>u,frontMatter:()=>s,metadata:()=>c,toc:()=>o});var a=r(5893),n=r(1151);const s={sidebar_position:5},i="Performance",c={id:"getting-started/performance",title:"Performance",description:"Mutative is a high-performance immutable data structure library, it is up to 2x-6x faster than naive handcrafted reducer and up to 16x faster than Immer.",source:"@site/docs/getting-started/performance.md",sourceDirName:"getting-started",slug:"/getting-started/performance",permalink:"/docs/getting-started/performance",draft:!1,unlisted:!1,editUrl:"https://github.com/unadlib/mutative/tree/main/website/docs/getting-started/performance.md",tags:[],version:"current",lastUpdatedBy:"unadlib",lastUpdatedAt:1758470239e3,sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Using Mutative with React",permalink:"/docs/getting-started/mutative-with-react"},next:{title:"Advanced Guides",permalink:"/docs/category/advanced-guides"}},d={},o=[{value:"Mutative vs Reducer Performance",id:"mutative-vs-reducer-performance",level:2},{value:"Reducer by object",id:"reducer-by-object",level:3},{value:"Reducer by array",id:"reducer-by-array",level:3},{value:"Mutative vs Immer Performance",id:"mutative-vs-immer-performance",level:2},{value:"More Performance Testing Scenarios",id:"more-performance-testing-scenarios",level:2}];function l(e){const t={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,n.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h1,{id:"performance",children:"Performance"}),"\n",(0,a.jsxs)(t.p,{children:["Mutative is a high-performance immutable data structure library, it is up to ",(0,a.jsx)(t.code,{children:"2x-6x"})," faster than naive handcrafted reducer and up to ",(0,a.jsx)(t.code,{children:"16x"})," faster than Immer."]}),"\n",(0,a.jsx)(t.h2,{id:"mutative-vs-reducer-performance",children:"Mutative vs Reducer Performance"}),"\n",(0,a.jsx)(t.h3,{id:"reducer-by-object",children:"Reducer by object"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Naive handcrafted reducer"}),"\n"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"// baseState type: Record<string, { value: number }>\nconst state = {\n  ...baseState,\n  key0: {\n    ...baseState.key0,\n    value: i,\n  },\n};\n"})}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Mutative"}),"\n"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"const state = create(baseState, (draft) => {\n  draft.key0.value = i;\n});\n"})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Mutative vs Reducer benchmark by object",src:r(1833).Z+"",width:"1000",height:"600"})}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsxs)(t.p,{children:["Measure(seconds) to update the 1K-100K items object, lower is better(",(0,a.jsx)(t.a,{href:"https://github.com/unadlib/mutative/blob/main/test/performance/benchmark-object.ts",children:"view source"}),")."]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsxs)(t.strong,{children:["Mutative is up to ",(0,a.jsx)(t.code,{children:"2x"})," faster than naive handcrafted reducer for updating immutable objects."]})}),"\n",(0,a.jsx)(t.h3,{id:"reducer-by-array",children:"Reducer by array"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Naive handcrafted reducer"}),"\n"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"// baseState type: { value: number }[]\n\n// slower 6x than Mutative\nconst state = [\n  { ...baseState[0], value: i },\n  ...baseState.slice(1, baseState.length),\n];\n\n// slower 2.5x than Mutative\n// const state = baseState.map((item, index) =>\n//   index === 0 ? { ...item, value: i } : item\n// );\n\n// same performance as Mutative\n// const state = [...baseState];\n// state[0] = { ...baseState[0], value: i };\n"})}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:"The actual difference depends on which spread operation syntax you use."}),"\n"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Mutative"}),"\n"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"const state = create(baseState, (draft) => {\n  draft[0].value = i;\n});\n"})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Mutative vs Reducer benchmark by array",src:r(480).Z+"",width:"1000",height:"600"})}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsxs)(t.p,{children:["Measure(seconds) to update the 1K-100K items array, lower is better(",(0,a.jsx)(t.a,{href:"https://github.com/unadlib/mutative/blob/main/test/performance/benchmark-array.ts",children:"view source"}),")."]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsxs)(t.strong,{children:["Mutative is up to ",(0,a.jsx)(t.code,{children:"6x"})," faster than naive handcrafted reducer for updating immutable arrays."]})}),"\n",(0,a.jsx)(t.h2,{id:"mutative-vs-immer-performance",children:"Mutative vs Immer Performance"}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:"Mutative passed all of Immer's test cases."}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["Measure(ops/sec) to update 50K arrays and 1K objects, bigger is better(",(0,a.jsx)(t.a,{href:"https://github.com/unadlib/mutative/blob/main/test/performance/benchmark.ts",children:"view source"}),"). [Mutative v1.3.0 vs Immer v10.1.3]"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Benchmark",src:r(7279).Z+"",width:"1000",height:"600"})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"Naive handcrafted reducer - No Freeze x 4,777 ops/sec \xb11.06% (94 runs sampled)\nMutative - No Freeze x 6,783 ops/sec \xb10.71% (96 runs sampled)\nImmer - No Freeze x 5.72 ops/sec \xb10.39% (19 runs sampled)\n\nMutative - Freeze x 1,069 ops/sec \xb10.75% (97 runs sampled)\nImmer - Freeze x 392 ops/sec \xb10.66% (92 runs sampled)\n\nMutative - Patches and No Freeze x 1,006 ops/sec \xb11.73% (95 runs sampled)\nImmer - Patches and No Freeze x 5.73 ops/sec \xb10.16% (19 runs sampled)\n\nMutative - Patches and Freeze x 548 ops/sec \xb11.06% (94 runs sampled)\nImmer - Patches and Freeze x 287 ops/sec \xb10.84% (93 runs sampled)\n\nThe fastest method is Mutative - No Freeze\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Run ",(0,a.jsx)(t.code,{children:"yarn benchmark"})," to measure performance."]}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:"OS: macOS 14.7, CPU: Apple M1 Max, Node.js: v22.11.0"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Immer relies on auto-freeze to be enabled, if auto-freeze is disabled, Immer will have a huge performance drop and Mutative will have a huge performance lead, especially with large data structures it will have a performance lead of more than 50x."}),"\n",(0,a.jsxs)(t.p,{children:["So if you are using Immer, you will have to enable auto-freeze for performance. Mutative is disabled auto-freeze by default. With the default configuration of both, we can see the 17x performance gap between Mutative (",(0,a.jsx)(t.code,{children:"6,783 ops/sec"}),") and Immer (",(0,a.jsx)(t.code,{children:"392 ops/sec"}),")."]}),"\n",(0,a.jsxs)(t.p,{children:["Overall, Mutative has a huge performance lead over Immer in ",(0,a.jsx)(t.a,{href:"https://github.com/unadlib/mutative/tree/main/test/performance",children:"more performance testing scenarios"}),". Run ",(0,a.jsx)(t.code,{children:"yarn performance"})," to get all the performance results locally."]}),"\n",(0,a.jsx)(t.h2,{id:"more-performance-testing-scenarios",children:"More Performance Testing Scenarios"}),"\n",(0,a.jsxs)(t.p,{children:["Mutative is up to ",(0,a.jsx)(t.code,{children:"2.5X-82.9X"})," faster than Immer:"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Mutative vs Immer - All benchmark results by average multiplier",src:r(5522).Z+"",width:"1000",height:"600"})}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.a,{href:"https://github.com/unadlib/mutative/blob/main/test/benchmark",children:"view source"}),"."]}),"\n"]})]})}function u(e={}){const{wrapper:t}={...(0,n.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},5522:(e,t,r)=>{r.d(t,{Z:()=>a});const a=r.p+"assets/images/all-1e5b3bdcb7c83f6fc8ce525634c10402.jpg"},480:(e,t,r)=>{r.d(t,{Z:()=>a});const a=r.p+"assets/images/benchmark-array-51cfcc5c02fb5b9d82d79f2b92097ad6.jpg"},1833:(e,t,r)=>{r.d(t,{Z:()=>a});const a=r.p+"assets/images/benchmark-object-68fad70750792b1a3b00d6978e7b93fd.jpg"},7279:(e,t,r)=>{r.d(t,{Z:()=>a});const a=r.p+"assets/images/benchmark-13c4761d7f2669e669166fe39e4132de.jpg"},1151:(e,t,r)=>{r.d(t,{Z:()=>c,a:()=>i});var a=r(7294);const n={},s=a.createContext(n);function i(e){const t=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:i(e.components),a.createElement(s.Provider,{value:t},e.children)}}}]);