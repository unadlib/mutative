"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[276],{763:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>d});var a=n(5893),r=n(1151);const i={sidebar_position:2},s="Currying",o={id:"advanced-guides/currying",title:"Currying",description:"Mutative allows for the creation of more modular and reusable state manipulation functions. This is achieved through a technique called currying, which transforms a function that takes multiple arguments into a sequence of functions.",source:"@site/docs/advanced-guides/currying.md",sourceDirName:"advanced-guides",slug:"/advanced-guides/currying",permalink:"/docs/advanced-guides/currying",draft:!1,unlisted:!1,editUrl:"https://github.com/unadlib/mutative/tree/main/website/docs/advanced-guides/currying.md",tags:[],version:"current",lastUpdatedBy:"unadlib",lastUpdatedAt:1702222992,formattedLastUpdatedAt:"Dec 10, 2023",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Patches",permalink:"/docs/advanced-guides/pathes"},next:{title:"Marking data structure",permalink:"/docs/advanced-guides/mark"}},c={},d=[{value:"Create a docs version",id:"create-a-docs-version",level:2},{value:"Base Currying",id:"base-currying",level:2},{value:"create draft",id:"create-draft",level:3},{value:"create producer",id:"create-producer",level:3},{value:"Enable Patches",id:"enable-patches",level:2}];function l(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h1,{id:"currying",children:"Currying"}),"\n",(0,a.jsx)(t.p,{children:"Mutative allows for the creation of more modular and reusable state manipulation functions. This is achieved through a technique called currying, which transforms a function that takes multiple arguments into a sequence of functions."}),"\n",(0,a.jsx)(t.h2,{id:"create-a-docs-version",children:"Create a docs version"}),"\n",(0,a.jsx)(t.p,{children:"Currying in Mutative refers to the technique of transforming a function that takes multiple arguments into a sequence of functions, each with a single argument. This approach is particularly useful in the context of state management, where it allows for greater flexibility and modularity in handling state updates."}),"\n",(0,a.jsx)(t.p,{children:"Key aspects of currying in Mutative include:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Modular State Management"}),": By using currying, developers can create more granular and composable functions to handle specific aspects of state updates. This enhances code readability and maintainability."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Flexibility in Function Invocation"}),": Currying allows for functions to be called with fewer arguments than they were defined to accept. This is useful in scenarios where state manipulation functions might need to be partially applied or reused across different contexts."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Enhanced Code Reusability"}),": With currying, the same base function can be adapted for different use cases by partially applying different arguments. This promotes code reusability and cleaner code architecture."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Integration with State Drafts"}),": Currying works well with Mutative's draft-based state management system, allowing developers to apply incremental changes to the state in a controlled and predictable manner."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Currying in Mutative offers a powerful way to handle state updates with more precision and clarity. It aligns with the principles of functional programming, bringing added benefits like modularity and reusability to state management. This makes Mutative a versatile tool for developers working on complex applications where efficient and maintainable state manipulation is key."}),"\n",(0,a.jsx)(t.h2,{id:"base-currying",children:"Base Currying"}),"\n",(0,a.jsx)(t.h3,{id:"create-draft",children:"create draft"}),"\n",(0,a.jsxs)(t.p,{children:["Support set options such as ",(0,a.jsx)(t.code,{children:"const [draft, finalize] = create(baseState, { enableAutoFreeze: true })"}),"."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"const [draft, finalize] = create(baseState);\ndraft.foobar.bar = 'baz';\nconst state = finalize();\n"})}),"\n",(0,a.jsx)(t.h3,{id:"create-producer",children:"create producer"}),"\n",(0,a.jsxs)(t.p,{children:["Also support set options such as ",(0,a.jsx)(t.code,{children:"const produce = create((draft) => {}, { enableAutoFreeze: true })"}),"."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"const produce = create((draft) => {\n  draft.foobar.bar = 'baz';\n});\nconst state = produce(baseState);\n"})}),"\n",(0,a.jsx)(t.h2,{id:"enable-patches",children:"Enable Patches"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"const baseState = {\n  foobar: { foo: 'str', bar: 'str' },\n  baz: { text: 'str' },\n};\n\nconst [draft, finalize] = create(baseState, { enablePatches: true });\ndraft.foobar.bar = 'baz';\nconst [state, patches, inversePatches] = finalize();\n\nexpect(state).toEqual(expectedResult);\nexpect(state).not.toBe(baseState);\nexpect(state.foobar).not.toBe(baseState.foobar);\nexpect(state.baz).toBe(baseState.baz);\nexpect(patches).toEqual([\n  {\n    op: 'replace',\n    path: ['foobar', 'bar'],\n    value: 'baz',\n  },\n]);\nexpect(inversePatches).toEqual([\n  {\n    op: 'replace',\n    path: ['foobar', 'bar'],\n    value: 'str',\n  },\n]);\n"})}),"\n",(0,a.jsx)(t.admonition,{type:"tip",children:(0,a.jsxs)(t.p,{children:["You can use the custom ",(0,a.jsx)(t.code,{children:"create()"})," function ",(0,a.jsx)(t.a,{href:"/docs/api-reference/create#createstate-fn-options---options",children:"option"})," to implement your own currying function."]})})]})}function u(e={}){const{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},1151:(e,t,n)=>{n.d(t,{Z:()=>o,a:()=>s});var a=n(7294);const r={},i=a.createContext(r);function s(e){const t=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),a.createElement(i.Provider,{value:t},e.children)}}}]);